
1.延迟脚本：defer="defer"
  IE4~IE7支持
  放在页面底部
  立即下载，页面加载完再执行

2.异步脚本：async
  异步加载脚本，不阻塞文档加载

--------------------------------------------------------------------------------

typeof
返回六种字符串
1."undefined" 未声明和未初始化的变量
2."boolean"
3."string"
4."number"
5."object"  null 一个空对象指针
6."function"

--------------------------------------------------------------------------------

不存在Null、Undefined类

Boolean类型
1.Boolean()转为false值：false、""、0和NaN、null、undefined

Number类型
1.八进制开头为0，然后1~7。070 严格模式不支持
2.十六进制开头为0x 0x1f
3.科学计数法 3.12e3 => 3120
4.Number.MIN_VALUE => 5e-324
  Number.MAX_VALUE => 1.7976931348623157e+308
5.-Infinity<Number.MIN_VALUE<Number.MAX_VALUE<Infinity isFinite方法判断
6.NaN与任何值不相等，包括NaN。isNaN方法判断
7.Number()、pareseInt()、parseFloat()
  1.true=>1,false=>0
  2.null=>0
  3.undefined=>NaN
  4.string:
    i.十进制、十六进制、浮点数，前面带0转为数值。八进制原样输出。
      "1"=>1 "011"=>11 "1.1"=>1.1 "0xf"=>15
    ii.空字符串转为0
    iii.其他转为NaN
  5.对象=>NaN

Number与parseInt区别:
1.空字串Number转为0，parseInt转为NaN
2.parseInt不解释无效数字  parseInt("1.1")=>1 parseInt("123blue")=>123
3.parseInt解释其他进制数字 parseInt("AF", 16)=>175

String类型
1.十六进制表示字符\x41=>"A"
  十六进制表示Unicode字符\u03a3=>Σ
2.不可变的
3.toString()输出其它进制数 num.toString(2)=>"1010" null、undefined没有toString方法
4.String()调用toString()，可以转null、undefined。
  null=>"null" undefined=>"undefined"

Object类型
继承属性：
constructor：保存创建对象的函数
hasOwnProperty：检查自定义属性
isPrototypeOf：检测c是否d的原型
  a.prototype.isPrototypeOf(b)=>true; b=new a();
  c.isPrototypeOf(d)=>true; c==d.\__proto__
propertyIsEnumerable:检查属性能否用for-in枚举

--------------------------------------------------------------------------------

操作符：
1.一元运行符 ++、--
  无效数字转为NaN
  对象先调用valueOf，再调用toString
2.位操作符
  负数二进制补码：1.正数二进制码。2.反码。0变1，1变0。3.反码加1
  按位非（NOT）~ 反码  ~25=>26
  按位与（AND）& 对应位都是1才返回1，其余为0。 25&3=>1
  按位或（OR）| 对应位有1返回1。 25|3=>27
  按位异或（XOR）^ 对应位只有一个1时返回1。 25^3=>26
  有符号左移<< 所有数值位向左移，不包括32号符号位 2<<5=>64
  有符号右移>> 所有数值位向右移，不包括32号符号位 64>>5=>2
  无符号右移>>> 所有位向右移，包括32号符号位。 -64>>>5=>134217726。正数变小，负数变大。
3.布尔操作符
  逻辑非（NOT）! 与Boolean()作用一样
  逻辑与（AND）&& 返回最左的false值。全为true则返回最后一个值。
  逻辑或（OR）|| 返回最左的true值。全为false则返回最后一个值。
4.加性操作符
  如果有字符串或对象，两边转为字符串
  其他的要转成数字计算
5.关系操作符
  i.两个字符串，比较编码值
  ii.对象先调用valueOf，再调用toString方法。如果没有值，最后才转成数值。
  iii.其他情况则转为数值比较

--------------------------------------------------------------------------------

语句：
do-while 至少执行一次
with 作用域设置到一个对象中

--------------------------------------------------------------------------------

arguments
1.可以通过arguments对参数赋值

--------------------------------------------------------------------------------

对象是按值传递的。

typeof 检测基本类型，instanceOf检测引用类型。

--------------------------------------------------------------------------------

执行环境：
1.每个执行环境都有一个变量对象，所有变量和函数保存在变量对象中。
2.全局环境是最外的执行环境。
3.函数执行完后，栈将其弹出，将控制权交给之前的执行环境。

作用域：
1.执行函数时，创建变量对象的一个作用域链。
2.作用域链的前端是变量对象，函数则是活动对象是变量对象。
3.活动对象包括arguments、外部的变量对象...直到全局变量对象。

标识符解析是沿着作用域链搜索的过程。

--------------------------------------------------------------------------------

延长作用域链
1.try-catch的catch
2.widh语句
两个会在作用域前端加一个变量对象。

--------------------------------------------------------------------------------

垃圾收集：
1.标记清除。当变量进入执行环境就标记，离开执行环境就清除。
2.引用计数。记录每个值引用数，被另一值引用加1 ，引用变量取其他值就减1。引用数为0时回收。
  1.缺点：无法清除环引用变量。

--------------------------------------------------------------------------------

基本类型值保存在栈内存中，引用类型的值是对象，保存在堆内存中。
引用类型值的变量并不是对象本身，而是一个指向该对象的指针；
基本类型用typeof，引用类型用instanceof。

--------------------------------------------------------------------------------

属性访问：
1.方括号法
2.点表示法

--------------------------------------------------------------------------------

Array类型
1.length可修改
2.toString()将数组转成用","分隔的字符串。valueOf原样输出。

1.栈方法（后入先出）：push、pop
2.队列方法（先入先出）：shift、unshift
3.重排方法：reverse、sort
  sort调用每项的toString，根据测试字符串改变顺序。
  a<b,-1，a>b,1是正序
4.归并方法：
  reduce/reduceRight：迭代所有项，返回最终值

--------------------------------------------------------------------------------

RegExp类型
1.在全局模式下每次调用exec(),lastIndex值都会添加

--------------------------------------------------------------------------------

Function类型
1.函数声明会提前解释，函数表达式则不会。

--------------------------------------------------------------------------------

数据属性：
1.Configurable=>true：能否用delete
2.Enumerable=>true：能否用for-in返回属性
3.Writable=>true：能否修改属性的值
4.Value=>undefined：读写属性

用Object.defineProperty()修改数据属性

访问器属性：
1.Configurable=>true：能否用delete
2.Enumerable=>true：能否用for-in返回属性
3.Get=>undefined：
4.Set=>undefined:

用Object.defineProperty() 来定义

```
var book = {
  _year: 2004,
    edition: 1
  };
  Object.defineProperty(book, "year", {
    get: function(){
      return this._year;
    },
    set: function(newValue){
      if (newValue > 2004) {
          this._year = newValue;
          this.edition += newValue - 2004;
      }
    }
  });
book.year = 2005;
alert(book.edition); //2
```

Object.getOwnPropertyDescriptor读取属性描述符

--------------------------------------------------------------------------------

工厂模式：创建对象
优点：解决创建多个相似对象的问题
缺点：没有解决对象识别的问题

构造函数模式：
1.直接将属性和方法赋给了this对象
2.没有return
优点：解决对象识别的问题(instanceof)
缺点：无法复用方法

new有四个作用:
1.创建一个新对象
2.将构造函数的作用域赋给新对象
3.执行构造函数代码
4.返回新对象

如果在构造函数中手动返回一个对象，则返回这个对象。

prototype（原型）：包含所有实例的共享属性和方法、创建对象的函数、继承属性
1.自定义属性和方法：new的时候会复制到实例中
2.constructor：指向创建新对象的函数，用来识别对象。数据属性[[enumerable]]为false。
3.\__proto__：实例化时复制构造函数的prototype属性。数据属性为undefined。
4.一个__proto__相当于new一个构造函数，并把构造函数的prototype赋值
5.instanceof、__proto__(prototype).isPrototypeOf(实例)

A、B构造函数
1.A.prototype=B.prototype   A改变导致B改变    √
2.A.prototype=new B()       创建新对象    √
3.深复制                     ×

in与hasOwnProperty
1.hasOwnProperty访问自定义属性
2.in可以访问原型属性，但不会自动访问
3.两者为true是自定义属性，in为true，hasOwnProperty为false为原型属性

实例中的指针仅指向原型，而不指向构造函数。
1.a.sayName=>a.\__proto__.sayName，而不指向A.prototype.sayName
2.Object.getPrototypeOf返回实例的原型，而不是构造函数的原型对象

原型模式：
1.属性放原型上，被所有实例共享
2.实例继承属性会影响所有实例的行为

优点：复用方法
缺点：没有参数，复用所有属性。

混合模式：
1.属性用放构造函数
2.方法放原型对象上
优点：属性可以自定义，方法可以复用

寄生构造函数模式：
1.用new，不用this
2.创建一个likeThis对象
3.添加自定义方法和属性
4.返回likeThis对象
缺点：对象与构造函数没有关系，不能用instanceof或Object.isPrototypeOf识别

稳妥构造函数模式：工厂模式的特例，工厂模式是它的父集。
1.用new，不用this
2.创建一个新对象
3.添加自定义方法和属性
4.返回新对象

--------------------------------------------------------------------------------

1.构造函数有原型对象，原型对象有构造函数
2.实例有原型对象
3.子对象继承父对象的属性和方法

A.prototype.constructor=>A
a.\__proto__=>A.prototype
SubType.prototype=new SuperType()

原型链搜索：
在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。

原型链：
缺点：原型模式的问题，属性也会被继承。

--------------------------------------------------------------------------------
// page186
借用构造函数：
1.用call执行父类的构造函数，用this获取父类的自定义。
2.
